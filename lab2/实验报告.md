

# 实验报告

## **1.复旦理发师问题**

### 1.1 关系分析（Q1）

这是一个典型的生产者消费者的有界缓冲区问题。在这道题目中，生产者是理发顾客`customer`，消费者是理发师`barber`，有界缓存区就是k 把供顾客等待坐的椅子`CHAIRS`，缓冲区中要放入的就是前来理发的顾客`customer`。

根据**课本**所给出的生产者消费者的有界缓冲区问题一般情况，在使用信号量`semaphore`的情况下， 生产者和消费者一般要共享以下数据结构：

```c
/*-------一般生产者消费者的有界缓冲区信号量模型----------*/
int n;	 						// 将缓冲区的大小
semaphore mutex = 1; 			// 提供缓冲区访问的互斥要求
semaphore empty = n;			// 缓冲区空闲的数量
semaphore full = 0;         	// 缓冲区被填充的数量
```

**课本**中生产者进程结构：

```c
do{
    wait(empty);			//使用一个空闲区
    wait(mutex);			//缓冲区互斥
    /*具体代码执行部分*/
    signal(mutex);
    signal(full)			//添加一个非空闲区
}while(true);
```

**课本**中消费者进程结构：

```c
do{
    wait(full);				//使用一个非空闲区
    wait(mutex);			//缓冲区互斥
    /*具体代码执行部分*/
    signal(mutex);
    signal(empty)			//添加一个空闲区
}while(true);
```

但是，由于题目中要求当排队人数超过椅子`CHAIRS`数量的时候，生产者`customer`就不再生产，选择离开，也就是**不需要**`semaphore empty`用来**同步**生产者的生产速度，而是需要一个新的量，`waiting`用来记录等待人数，这就需要提供**新的信号量**`semaphore waiting_mutex`来提供互斥要求。

所以在该题目下，生产者`customer`和消费者`barber`共享以下数据结构：

```c
#define CHAIRS 5 				// 将缓冲区的大小定义为5
semaphore mutex = 1; 			// 提供缓冲区访问的互斥要求
semaphore waiting_mutex = 1;	// 提供等待人数访问的互斥要求
semaphore full = 0;   			// 缓冲区被填充的数量
```

`semaphore mutex  `提供缓冲区访问的互斥要求，理发师让下一个顾客来理发，和新的顾客到理发店，在时间上总存在先后，所以缓冲区的访问是互斥的。

`semaphore waiting_mutex`用来限制等待人数的修改，理发师理完一个人，要对等待人数`waiting`-1，而每当有一个顾客成功进入队列，要对等待人数`waiting`+1，理发师和顾客不能同时修改等待人数。

`semaphore full`缓冲区被填充的数量，若`full`为0，则理发店老板`barber`睡觉，进入等待模式，直到有顾客来使得，老板被叫醒。

由于在该实现所以在该题目下，由于`mutex`和`waiting_mutex`只是提供互斥，没有必要使用信号量，改为互斥量`pthread_mutex_t`，所以==最后==生产者`customer`和消费者`barber`共享以下数据结构：

```c
#define CHAIRS 5 				// 将缓冲区的大小定义为5
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;         // 提供缓冲区访问的互斥要求
pthread_mutex_t waiting_mutex = PTHREAD_MUTEX_INITIALIZER; // 提供等待人数访问的互斥要求
semaphore full;                                            // 缓冲区被填充的数量
```

### 1.2 进程实现（Q2）

根据生产者消费者的有界缓冲区模型，可以实现至少2个进程，生产者是理发顾客`customer`，消费者是理发师`barber`。我在本题的处理中，每一个顾客是一个线程，理发师是一个线程来处理顾客的理发需求。

为了方便数据的共享，下面代码是使用**线程**的方式实现的的该问题，使用`pthreads`进行同步。

#### 1.1.1缓冲区

根据问题分析中的**缓冲区**模型，下面定义缓冲区，缓冲区就是等待顾客的椅子`chairs`，使用一个`int`数组记录每位到来的顾客的`id`，`id`就是顾客前来的顺序，从0开始依次增加。

```c
int chairs[CHAIRS];    //缓冲区数组
int nextCustomers = 0; //指向下一位等待的顾客
int nextChair = 0;     //指向下一个空椅子
```

#### 1.1.2生产者——顾客

在实现中每一位顾客`customer`都是一个线程，与一般模型不同，在处理等待人数的是时候，如果等待人数超过椅子`CHAIRS`的数量，顾客就离开，不会阻塞在理发店门口，所以这里使用if语句进行判断。

```c
void *customer(void *num)
{
    pthread_mutex_lock(&waiting_mutex);
        if (waiting < CHAIRS)
        {
            //等待人数加一
            waiting += 1;

            pthread_mutex_lock(&mutex);//顾客坐上椅子等待被叫
                /* 中间处理缓冲区的修改*/
            pthread_mutex_unlock(&mutex);
        }
        else
        {
            // 顾客没有位置离开
        }
    pthread_mutex_unlock(&waiting_mutex);  
  
    sem_post(&full);		//使用信号量 告诉理发师有客人来
}
```

#### 1.1.3消费者——理发师

消费者`barber`的结构与典型的生产者消费者的有界缓冲区一致，只是最后的等待人数`waiting`使用互斥量手动修改，而不是直接用信号量来修改。

```c
void *barber(void)
{
    while (1)
    {
        sem_wait(&full);            //使用信号量 等待客人来
      
        pthread_mutex_lock(&mutex); //有客人，读取客人id 进行理发
			/* 中间处理缓冲区的修改*/
        pthread_mutex_unlock(&mutex);

        //送走客人
        pthread_mutex_lock(&waiting_mutex);
        waiting -= 1;
        pthread_mutex_unlock(&waiting_mutex);
    }
}
```

#### 1.1.4main函数

main函数就是初始化线程，并逐一释放顾客线程。

这里定义等待椅子数量`CHAIRS`为5，总的顾客前来数量` num_customers`为20

```c
int main()
{
    pthread_t p_barber;
    pthread_t p_customers[20];

    int num_customers = 20;

    sem_init(&full, 0, 0);

    pthread_create(&p_barber, 0, barber, 0);
    for (int i = 0; i < num_customers; i++)
    {
        pthread_create(&p_customers[i], 0, customer, &i);
        sleep(1);
        if (i == 8)//第9个顾客来后到午饭时间，一段时间内没有顾客来
        {
            sleep(10);
        }
    }
    for (int i = 0; i < num_customers; i++)
    {
        pthread_join(p_customers[i], 0);
    }
    sleep(10);
    return 0;
}
```

## 2.直播间问题

### 2.1 关系分析（Q1）

这是一个读者-作者问题，但其中为了实现纪录片的顺序播放又包含了生产者消费者的有界缓冲区问题。在这道题目中，第一个进入直播间、决定下一步纪录片的B站观众` keyViewer`是作者，他选择了当前直播间播放的电影。想要观看的纪录片和直播间正在播放的一致的B站观众` viewer`是读者。产生下一步纪录片观影需求的B站观众` keyViewer`是生产者，正在播放的纪录片`Target current_Documentary`是消费者。

#### 2.1.1课本案例分析

根据**课本**给出的读者-作者模型，读者和作者共享以下数据结构：

```c
semaphore rw_mutex = 1;			//用于读者和作者的互斥
semaphore mutex = 1;			//用于确保read_count更新时的互斥
int read_count = n;
```

变量`read_count`用于记录同时在读取的读者，由于读和写不是一一对应的关系，不能向生产者消费者一样就用信号量同步读写数量，所以必须用一个变量来记录同时在读的人数。

**课本**中作者进程结构：

```c
do{
    wait(re_mutex);
    /*处理内容*/
    signal(rw_mutex);
}while(true);
```

**课本**中读者进程结构：

```c
do{
    wait(mutex);		//确保read_count更新时的互斥
    read_count++;
    if(read_count == 1)	//如果是第一个读者，等待作者写
        wait(rw_mutex);
    signal(mutex);		//结束read_count 更新时的互斥
    /*处理内容*/
    wait(mutex);
    read_count--;
    if(read_count == 0)
        signal(rw_mutex);
    signal(mutex);  
}while(true);
```

#### 2.1.2本题关系分析

上面`1.1.1`中的结构是读者优先，只要还有读者在读，作者就被阻塞。对应**本题**，作者就是` keyViewer`，读者就是`viewer`，进出直播间，我们需要维护一个正在播放的纪录片`Target current_Documentary`，使用数据结构`Target`对每一个纪录片对象进行记录。

```c
typedef struct target
{
    char documentary[32];   //纪录片名称
    int documentaryID;      //纪录片ID
    int documentary_time;   //纪录片时长
    int viewing_time; 		//用户预期观影时间 
} Target;
```

所以**本题**的读者和作者应该共享共享以下数据结构：

```c
semaphore rw_mutex = 1;			//用于读者和作者的互斥
semaphore mutex = 1;			//用于确保viewer_count和current_Documentary更新时的互斥
int viewer_count = 0;			//正在观看的人数 初始化为0
Target current_Documentary;		//维护的正在播放的纪录片
```

**但是**，题目中第3点要求，等待观看其他纪录片的 b 站用户按到达顺序排队，这里又**嵌套**了一个生产者消费者的有界缓冲区问题，满足了正在观看的观众`viewer`要**按顺序**去满足接下来的观众。在这一条件下，生产者是` keyViewer`，消费者是`Target current_Documentary`。

定义一个新的数据结构元素`Element`，记录接下来要观影的需求，元素`Element`的数组就是生产者`keyViewer`和消费者`current_Documentary`的缓冲区。

```c
typedef struct element
{
    semaphore mutex = 1; 	 //用于确保该纪录片的viewer_count更新时的互斥
    int viewer_count = 0;	 //正在观看的人数 初始化为0
    Target Documentary;		//要观看的纪录片
} Element;
```

所以在该题目下，生产者`keyViewer`和消费者`current_Documentary`共享以下数据结构：

```c
#define ELEMENTS 3 			// 将缓冲区的大小定义为3
semaphore element_mutex = 1; 	// 提供缓冲区访问的互斥要求
semaphore full = 0;   			// 缓冲区被填充的数量
/*注本题中不需要缓冲区空闲的数量的信号，主要是因为纪录片数量有限，不会超过缓冲区大小。*/
```

所以最后的读者和作者应该共享共享以下数据结构：

~~~~~~
要改要改要改要改要改要改要改要改
~~~~~~

```c
semaphore rw_mutex = 1;			//用于读者和作者的互斥
semaphore mutex = 1;			//用于确保viewer_count和current_Documentary更新时的互斥
int viewer_count = 0;			//正在观看的人数 初始化为0
Target current_Documentary;		//维护的正在播放的纪录片
```

`semaphore queue_mutex  `提供缓冲区访问的互斥要求，每一个观众`viewer`进入直播间，要必须先进入元素`Element`的数组，进行用户的**分类**，并进入到对应的纪录片下，如果存在对应元素`Element`，就在元素`Element`中增加`viewer_count`，如果没有元素`Element`有对应的纪录片，则生成一个有对应的纪录片元素`Element`，完成生产者的生产。

消费者是一个直播间`liveRoom`





### 2.2进程实现（Q2）
