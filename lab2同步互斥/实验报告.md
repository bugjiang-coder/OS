# 实验报告

## **1.复旦理发师问题** 

### 1.1 关系分析（Q1）

这是一个典型的生产者消费者的有界缓冲区问题。在这道题目中，生产者是理发顾客`customer`，消费者是理发师`barber`，有界缓存区就是k 把供顾客等待坐的椅子`CHAIRS`，缓冲区中要放入的就是前来理发的顾客`customer`。

根据**课本**所给出的生产者消费者的有界缓冲区问题一般情况，在使用信号量`semaphore`的情况下， 生产者和消费者一般要共享以下数据结构：

```c
/*-------一般生产者消费者的有界缓冲区信号量模型----------*/
int n;	 						// 将缓冲区的大小
semaphore mutex = 1; 			// 提供缓冲区访问的互斥要求
semaphore empty = n;			// 缓冲区空闲的数量
semaphore full = 0;         	// 缓冲区被填充的数量
```

**课本**中生产者进程结构：

```c
do{
    wait(empty);			//使用一个空闲区
    wait(mutex);			//缓冲区互斥
    /*具体代码执行部分*/
    signal(mutex);
    signal(full)			//添加一个非空闲区
}while(true);
```

**课本**中消费者进程结构：

```c
do{
    wait(full);				//使用一个非空闲区
    wait(mutex);			//缓冲区互斥
    /*具体代码执行部分*/
    signal(mutex);
    signal(empty)			//添加一个空闲区
}while(true);
```



但是，由于题目中要求当排队人数超过椅子`CHAIRS`数量的时候，生产者`customer`就不再生产，选择离开，也就是**不需要**`semaphore empty`用来**同步**生产者的生产速度，而是需要一个新的量，`waiting`用来记录等待人数，这就需要提供**新的信号量**`semaphore waiting_mutex`来提供互斥要求。

所以在该题目下，生产者`customer`和消费者`barber`共享以下数据结构：

```c
#define CHAIRS = 5 				// 将缓冲区的大小定义为5
semaphore mutex = 1; 			// 提供缓冲区访问的互斥要求
semaphore waiting_mutex = 1;	// 提供等待人数访问的互斥要求
semaphore full = 0;   			// 缓冲区被填充的数量
```

`semaphore mutex  `提供缓冲区访问的互斥要求，理发师让下一个顾客来理发，和新的顾客到理发店，在时间上总存在先后，所以缓冲区的访问是互斥的。

`semaphore waiting_mutex`用来限制等待人数的修改，理发师理完一个人，要对等待人数`waiting`-1，而每当有一个顾客成功进入队列，要对等待人数`waiting`+1，理发师和顾客不能同时修改等待人数。

`semaphore full`缓冲区被填充的数量，若`full`为0，则理发店老板`barber`睡觉，进入等待模式，直到有顾客来使得，老板被叫醒。



由于在该实现所以在该题目下，由于`mutex`和`waiting_mutex`只是提供互斥，没有必要使用信号量，改为信号量`pthread_mutex_t`，所以最后生产者`customer`和消费者`barber`共享以下数据结构：

```c
#define CHAIRS = 5 				// 将缓冲区的大小定义为5
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;         // 提供缓冲区访问的互斥要求
pthread_mutex_t waiting_mutex = PTHREAD_MUTEX_INITIALIZER; // 提供等待人数访问的互斥要求
semaphore full;                                            // 缓冲区被填充的数量
```



### 1.2 进程实现（Q2）

根据生产者消费者的有界缓冲区模型，可以实现至少2个进程，生产者是理发顾客`customer`，消费者是理发师`barber`。我在本题的处理中，每一个顾客是一个线程，理发师是一个线程来处理顾客的理发需求。

为了方便数据的共享，下面代码是使用**线程**的方式实现的的该问题，使用`pthreads`进行同步。

#### 1.1.1缓冲区

根据问题分析中的**缓冲区**模型，下面定义缓冲区，缓冲区就是等待顾客的椅子`chairs`，使用一个`int`数组记录每位到来的顾客的`id`，`id`就是顾客前来的顺序，从0开始依次增加。

```c
int chairs[CHAIRS];    //缓冲区数组
int nextCustomers = 0; //指向下一位等待的顾客
int nextChair = 0;     //指向下一个空椅子
```



#### 1.1.2生产者——顾客

在实现中每一位顾客`customer`都是一个线程，与一般模型不同，在处理等待人数的是时候，如果等待人数超过椅子`CHAIRS`的数量，顾客就离开，不会阻塞在理发店门口，所以这里使用if语句进行判断。

```c
void *customer(void *num)
{
    pthread_mutex_lock(&waiting_mutex);
        if (waiting < CHAIRS)
        {
            //等待人数加一
            waiting += 1;

            pthread_mutex_lock(&mutex);//顾客坐上椅子等待被叫
                /* 中间处理缓冲区的修改*/
            pthread_mutex_unlock(&mutex);
        }
        else
        {
            // 顾客没有位置离开
        }
    pthread_mutex_unlock(&waiting_mutex);    
    
    sem_post(&full);		//使用信号量 告诉理发师有客人来
}
```





#### 1.1.3消费者——理发师

消费者`barber`的结构与典型的生产者消费者的有界缓冲区一致，只是最后的等待人数`waiting`使用互斥量手动修改，而不是直接用信号量来修改。

```c
void *barber(void)
{
    while (1)
    {
        sem_wait(&full);            //使用信号量 等待客人来
        
        pthread_mutex_lock(&mutex); //有客人，读取客人id 进行理发
			/* 中间处理缓冲区的修改*/
        pthread_mutex_unlock(&mutex);

        //送走客人
        pthread_mutex_lock(&waiting_mutex);
        waiting -= 1;
        pthread_mutex_unlock(&waiting_mutex);
    }
}
```



#### 1.1.4main函数

main函数就是初始化线程，并逐一释放顾客线程。

这里定义等待椅子数量`CHAIRS`为5，总的顾客前来数量` num_customers`为20

```c
int main()
{
    pthread_t p_barber;
    pthread_t p_customers[20];

    int num_customers = 20;

    sem_init(&full, 0, 0);

    pthread_create(&p_barber, 0, barber, 0);
    for (int i = 0; i < num_customers; i++)
    {
        pthread_create(&p_customers[i], 0, customer, &i);
        sleep(1);
        if (i == 8)//第9个顾客来后到午饭时间，一段时间内没有顾客来
        {
            sleep(10);
        }
    }
    for (int i = 0; i < num_customers; i++)
    {
        pthread_join(p_customers[i], 0);
    }
    sleep(10);
    return 0;
}
```





## 2.直播间问题

### 1.1 关系分析（Q1）

这是一个典型的读者-作者问题。在这道题目中，第一个进入直播间的B站观众` viewer`是作者，他选择了当前直播间播放的电影，

```c
typedef struct target
{
    char movie[32];   //电影名称
    int movieID;      //电影ID
    int movie_time;   //电影时长
    int viewing_time; //顾客预期观影时间
} Target;
```

