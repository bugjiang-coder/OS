# 实验报告

## **1.复旦理发师问题** 

### 1.1 问题分析

这是一个典型的生产者消费者的有界缓冲区问题。在这道题目中，生产者是理发顾客`customer`，消费者是理发师`barber`，有界缓存区就是k 把供顾客等待坐的椅子`CHAIRS`，缓冲区中要放入的就是前来理发的顾客`customer`。

根据**课本**所给出的生产者消费者的有界缓冲区问题一般情况，生产者和消费者一般要共享以下数据结构：

```c
/*-------一般生产者消费者的有界缓冲区模型----------*/
int n;	 						// 将缓冲区的大小
semaphore mutex = 1; 			// 提供缓冲区访问的互斥要求
semaphore empty = n;			// 缓冲区空闲的数量
semaphore full = 0;         	// 缓冲区被填充的数量
```

但是，由于题目中要求当排队人数超过椅子`CHAIRS`数量的时候，生产者`customer`就不再生产，选择离开，也就是**不需要**`semaphore empty`用来**同步**生产者的生产速度，而是需要一个新的量，`waiting`用来记录等待人数，这就需要提供**新的互斥锁**`semaphore waiting_mutex`来提供互斥要求。



所以在该题目下，生产者`customer`和消费者`barber`共享以下数据结构：

```c
#define CHAIRS = 5 				// 将缓冲区的大小定义为5
semaphore mutex = 1; 			// 提供缓冲区访问的互斥要求
semaphore waiting_mutex = 1;	// 提供等待人数访问的互斥要求
semaphore full = 0;   			// 缓冲区被填充的数量
```

`semaphore mutex  `提供缓冲区访问的互斥要求，理发师让下一个顾客来理发，和新的顾客到理发店，在时间上总存在先后，所以缓冲区的访问是互斥的。

`semaphore waiting_mutex`用来限制等待人数的修改，理发师理完一个人，要对等待人数`waiting`-1，而每当有一个顾客成功进入队列，要对等待人数`waiting`+1，理发师和顾客不能同时修改等待人数。

`semaphore full`缓冲区被填充的数量，若`full`为0，则理发店老板`barber`睡觉，进入等待模式，直到有顾客来使得，老板被叫醒。



### 1.2 进程实现

根据生产者消费者的有界缓冲区模型，可以实现两个进程，生产者是理发顾客`customer`，消费者是理发师`barber`。

为了方便数据的共享，下面代码是使用**线程**的方式实现的的该问题，使用`pthreads`进行同步。





