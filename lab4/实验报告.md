# 实验报告

实验任务:

以下部分任务点可能涉及到具体内存管理的代码细节，本次实验不做要求，但关于mmio等宏观设计概念，需要大家在报告中体现出来。

涉及的代码文件：

```txt
kern/cpu.h 			多处理器支持的内核私有定义
kern/mpconfig.c 	读取多处理器配置的代码
kern/lapic.c 		驱动每个处理器中本地 APIC 单元的内核代码
kern/mpentry.S 		非引导 CPU 的汇编语言入口代码
kern/spinlock.h 	自旋锁的内核私有定义，包括大内核锁
kern/spinlock.c 	实现自旋锁的内核代码
kern/sched.c 		您将要实现的调度程序的代码框架
```



1. 多处理器

让JOS支持**对称多重处理**`symmetric multiprocessing `（SMP）

一个多处理器模块，其中所有CPU均具有对系统资源（例如内存和IO总线）的**同等**访问权限。所有CPU在SMP中在功能上都是相同的，

在启动过程中，它们可以分为两种类型：

**引导处理器**`bootstrap processor`（BSP）负责初始化系统并启动操作系统;并且只有在操作系统启动并运行后，**应用处理器**`application processors`(APs)才能由BSP激活。哪个处理器是BSP，这取决于硬件和BIOS。到目前为止，所有现有的JOS代码都已在BSP上运行。	

在SMP系统中，每个CPU都有一个随附的本地APIC`Advanced Programmable Interrupt Controller`(高级可编程中断控制器)（LAPIC）单元。LAPIC单元负责在整个系统中传递中断。LAPIC还为其连接的CPU提供唯一标识符。在这个lab里，我们利用LAPIC单元的以下基本功能（在kern / lapic.c中）。

处理器使用内存映射的I / O（MMIO）访问其LAPIC。 在MMIO中，一部分物理内存被硬连线到某些I / O设备的寄存器，因此通常用于访问内存的相同加载/存储指令可用于访问设备寄存器。 您已经在物理地址**0xA0000**处看到一个IO孔（我们使用它来写入CGA display buffer）。 LAPIC位于一个从物理地址**0xFE000000**（比4GB小32MB）开始的孔中，因此对于我们来说，使用我们在KERNBASE的常规直接映射进行访问的空间过高。 JOS虚拟内存映射在MMIOBASE上留下了4MB的空间，因此我们有一个映射这样的设备的地方。 由于以后的lab会引入更多的MMIO区域，因此您将编写一个简单的函数从该区域分配空间并将设备内存映射到该区域。





## 任务一

> 基于MIT JOS LAB4 **Exercise** 1 , （关于pmap.c 的代码要求助教已经帮大家实现基本功能），要求大家：(1). 阅读kern/pmap.c 关于mmio_map_region的实现，理解mmio_map的具体原理，包括boot_map_region的原理。在实验报告中详细写明。
>

### 1. 背景

MMIO(Memory mapping I/O)即内存映射I/O，它是PCI规范的一部分，I/O设备被放置在内存空间而不是I/O空间。从处理器的角度看，内存映射I/O后**系统设备访问起来和内存一样**。在MMIO中，一部分物理内存被**硬连线**到某些I/O设备的寄存器，因此我们可以用和访问内存的相同加载/存储指令来访问设备寄存器。 



### 2. 目的

LAPIC位于一个从物理地址**0xFE000000**（比4GB小32MB）开始的孔中，远远**高于**`KERNBASE`的常规直接映射，所以JOS**虚拟内存映射**在`MMIOBASE`上留下了**4MB**的空间，因此我们有一个映射这样的设备的地方。所以`mmio_map_region`这一个函数主要就是将一个物理地址`pa`和它的大小`size`映射到JOS定义好的`Memory-mapped I/O`虚拟地址上去，虚拟地址空间如下：

```txt
 Virtual memory map:                                Permissions
                                                    kernel/user
                     :              .               :                   
                     :              .               :                   
    MMIOLIM ------>  +------------------------------+ 0xefc00000      
                     |       Memory-mapped I/O      | RW/--  PTSIZE
 ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
                     .                              .
                     .                              .
```



### 3. 实现

(1) 根据JOS标准设置基地址`base`

```c
static uintptr_t base = MMIOBASE;
```

(2) 由于输入的大小不一定是`PGSIZE`的倍数，所以先利用宏定义取`PGSIZE`的倍数

```c
size = ROUNDUP(pa + size, PGSIZE);
pa = ROUNDDOWN(pa, PGSIZE);
size -= pa;
```

(3) 判断是否超过`MMIOLIM`

```c
if (base + size >= MMIOLIM)
    panic("not enough memory");
```

(4) 调用映射函数`boot_map_region`

```c
boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);
```

在内核的初始页面目录上，将LAPIC的物理地址映射到设计的虚拟地址上，并对页表条目进行设置`PTE_PCD | PTE_PWT | PTE_W`缓存禁用、写完、可写。

`boot_map_region`的原理就是根据虚拟地址`va`获取到对应的页表条目`pte`，然后将页表条目`pte`设置为物理地址：

```c
static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// 将要映射的大小填充到 页面大小的整数倍
	size_t pgs = size / PGSIZE;
	if (size % PGSIZE != 0)
	{
		pgs++;
	}
	for (int i = 0; i < pgs; i++)
	{
        // 取得每一个页面的页表条目pte
		pte_t *pte = pgdir_walk(pgdir, (void *)va, 1);
		if (pte == NULL)
		{
			panic("boot_map_region(): out of memory\n");
		}
        // 将页表条目pte设置到对应为物理地址，同时设置flag
		*pte = pa | PTE_P | perm;
		pa += PGSIZE;
		va += PGSIZE;
	}
}
```



(5) 返回基地址，设置基地址`base`







## 任务二

> 回答问题 Exercise 2 Question 1。在实验报告中详细写明，涉及到的关键代码最好使用图片或其他形式嵌入到报告中予以解释。



1.将kern / mpentry.S与boot / boot.S并排比较。 kern / mpentry.S就像内核中的所有其他内容一样经过编译和链接以在KERNBASE之上运行，宏MPBOOTPHYS的目的是什么？ 为什么在kern / mpentry.S中有必要，但在boot / boot.S中却没有必要？ 换句话说，如果在kern / mpentry.S中省略了它，那会出什么问题？ 
Hint：回忆一下我们在实验1中讨论的链接地址和加载地址之间的区别。

answer：mpentry_start, mpentry_end是LMA，内核在启动AP之前将这个地址映射到了MPENTRY_PADDR（VMA），AP启动还没进protect mode之前只能使用物理地址，而实际上这时候BSP已经到kernel状态，gdt的地址都是线性地址，所以需要一个宏来转换成物理地址。boot.S还没进protect mode，访问的都是物理地址。







## 任务三

> 阅读Exercise 4 中trap_init_percpu()函数（助教已经实现），理解是如何在多个cpu上运行的。并在实验报告中解释说明。







## 任务四

> 回答 Question 2， 并且理解 Challenge *Challenge!* The big kernel lock is simple and easy to use... 的相关实现，将理解在实验报告中写明。





## 任务五

> 回答 Question3 和 Question4 ，其中涉及到的代码助教已经实现，请将理解以及相关关键代码在实验报告中写明。
>